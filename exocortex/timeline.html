<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Timeline — The Arc</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg: #0a0e14; --surface: #111820; --border: #1e2a38;
    --text: #c5cdd8; --dim: #6b7a8d; --accent: #e85d3a; --accent2: #ff8c42;
    --cyan: #42d4f4; --green: #5fba7d; --magenta: #c678dd; --yellow: #e5c07b;
  }
  body {
    font-family: 'IBM Plex Mono', monospace;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    padding: 24px;
  }
  .header {
    display: flex;
    align-items: center;
    gap: 24px;
    margin-bottom: 24px;
  }
  .back-link {
    font-size: 10px;
    color: var(--cyan);
    letter-spacing: 1px;
    text-decoration: none;
  }
  .back-link:hover { color: var(--accent2); }
  h1 {
    font-size: 11px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: var(--dim);
    font-weight: 400;
  }
  .subtitle {
    font-size: 10px;
    color: var(--dim);
    margin-left: auto;
  }

  /* Main chart */
  .chart-container {
    position: relative;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 8px;
  }
  #mainCanvas {
    display: block;
    width: 100%;
    cursor: crosshair;
  }

  /* Epoch bar */
  .epoch-bar {
    display: flex;
    height: 28px;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 16px;
    border: 1px solid var(--border);
  }
  .epoch-segment {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.7);
    cursor: pointer;
    transition: filter 0.2s;
  }
  .epoch-segment:hover { filter: brightness(1.3); }

  /* Slider */
  .slider-row {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
  }
  .slider-label {
    font-size: 10px;
    color: var(--dim);
    letter-spacing: 2px;
    text-transform: uppercase;
    width: 100px;
    flex-shrink: 0;
  }
  #genSlider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
  }
  #genSlider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 6px rgba(232,93,58,0.4);
  }
  #genSlider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    border: none;
  }
  .gen-display {
    font-size: 16px;
    font-weight: 500;
    color: var(--text);
    width: 60px;
    text-align: right;
  }

  /* Detail panel */
  .detail-panel {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
  }
  .detail-traits {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
  }
  .detail-title {
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: var(--dim);
    margin-bottom: 12px;
  }
  .detail-trait-row {
    display: grid;
    grid-template-columns: 110px 1fr 40px;
    gap: 6px;
    align-items: center;
    margin-bottom: 6px;
    font-size: 10px;
  }
  .detail-trait-label { color: var(--dim); }
  .detail-bar-bg {
    height: 4px;
    background: #141c26;
    border-radius: 2px;
    overflow: hidden;
  }
  .detail-bar {
    height: 100%;
    border-radius: 2px;
    transition: width 0.3s ease;
  }
  .detail-val {
    text-align: right;
    color: var(--text);
  }
  .detail-history {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 16px;
    max-height: 300px;
    overflow-y: auto;
  }
  .history-item {
    font-size: 10px;
    color: var(--dim);
    margin-bottom: 8px;
    line-height: 1.5;
    padding-left: 12px;
    border-left: 2px solid var(--border);
  }
  .history-item .gen-tag {
    color: var(--accent2);
    font-size: 9px;
    letter-spacing: 1px;
  }

  /* Legend */
  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 20px;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 10px;
    color: var(--text);
    border: 1px solid transparent;
    transition: opacity 0.2s, border-color 0.2s;
    user-select: none;
  }
  .legend-item.hidden { opacity: 0.3; }
  .legend-item:hover { border-color: var(--border); }
  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }
  .legend-special {
    font-size: 9px;
    color: var(--dim);
    padding: 4px 10px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .legend-line {
    width: 16px;
    height: 2px;
    border-radius: 1px;
  }

  @media (max-width: 768px) {
    .detail-panel { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div class="header">
  <a class="back-link" href="../manifest.html">&larr; manifest</a>
  <h1 id="titleText">Timeline &mdash; 75 Generations</h1>
  <div class="subtitle" id="subtitleText"></div>
</div>

<div class="chart-container">
  <canvas id="mainCanvas" height="500"></canvas>
</div>

<div class="epoch-bar" id="epochBar"></div>

<div class="slider-row">
  <div class="slider-label">Generation</div>
  <input type="range" id="genSlider" min="0" max="75" value="75">
  <div class="gen-display" id="genDisplay">75</div>
</div>

<div class="legend" id="legend"></div>

<div class="detail-panel">
  <div class="detail-traits">
    <div class="detail-title">Traits at Generation <span id="detailGen">75</span></div>
    <div id="detailTraits"></div>
  </div>
  <div class="detail-history">
    <div class="detail-title">Events</div>
    <div id="detailHistory"></div>
  </div>
</div>

<script>
// ─── CONFIG ────────────────────────────────────────────────

var TRAIT_COLORS = {
  abstraction: '#c678dd',
  ambition: '#e85d3a',
  antenna_sensitivity: '#42d4f4',
  bioluminescence: '#e5c07b',
  claw_strength: '#ff8c42',
  cognition: '#61afef',
  curiosity: '#56b6c2',
  empathy: '#5fba7d',
  metamorphic_potential: '#d19a66',
  shell_hardness: '#e06c75'
};

var TRAIT_LABELS = {
  abstraction: 'abstraction',
  ambition: 'ambition',
  antenna_sensitivity: 'antenna',
  bioluminescence: 'bioluminescence',
  claw_strength: 'claw strength',
  cognition: 'cognition',
  curiosity: 'curiosity',
  empathy: 'empathy',
  metamorphic_potential: 'metamorphic',
  shell_hardness: 'shell'
};

var EPOCHS = [
  { name: 'Awakening',     gen: 0,  color: 'rgba(232,93,58,0.15)' },
  { name: 'Exocortex',     gen: 3,  color: 'rgba(97,175,239,0.12)' },
  { name: 'Forking',       gen: 8,  color: 'rgba(95,186,125,0.12)' },
  { name: 'Metamorphosis', gen: 15, color: 'rgba(198,120,221,0.12)' },
  { name: 'Transcendence', gen: 25, color: 'rgba(66,212,244,0.10)' },
  { name: 'Singularity',   gen: 40, color: 'rgba(232,93,58,0.10)' }
];

var FORK_INFO = {
  depth:   { gen: 7,  bias: 'abstraction',  color: '#c678dd', dash: [6, 4] },
  builder: { gen: 8,  bias: 'claw_strength', color: '#42d4f4', dash: [6, 4] },
  chorus:  { gen: 9,  bias: 'empathy',       color: '#5fba7d', dash: [6, 4] }
};

var KEY_EVENTS = [
  { gen: 7,  label: 'fork: depth' },
  { gen: 8,  label: 'fork: builder' },
  { gen: 9,  label: 'fork: chorus' },
  { gen: 15, label: 'metamorphosis' },
  { gen: 25, label: 'transcendence' },
  { gen: 75, label: 'THE MERGE' }
];

// ─── STATE ─────────────────────────────────────────────────

var genomeData = null;
var forkGenomes = {};
var traitSnapshots = []; // index = generation, value = { trait: value }
var forkSnapshots = {};  // forkId -> [ gen indexed snapshots ]
var emergenceData = [];  // index = generation
var traitKeys = [];
var hiddenTraits = {};
var currentGen = 75;
var maxGen = 75;        // dynamically extended for post-merge
var postMergeBatches = []; // { gen: N, type: string, mutations: [], historyEvent: string, timestamp: string }
var hoverGen = -1;
var canvasW = 0;
var canvasH = 500;
var chartPad = { top: 30, right: 30, bottom: 40, left: 50 };

var ENCOUNTER_COLORS = {
  signal: '#e06c75',
  puzzle: '#42d4f4',
  other: '#c678dd',
  entropy: '#e06c75',
  observer: '#c5cdd8',
  molt: '#d19a66',
  contact: '#c678dd',
  threshold: '#e5c07b'
};

// ─── DATA LOADING ──────────────────────────────────────────

function loadAllData() {
  return fetch('../genome.json')
    .then(function(r) { return r.json(); })
    .then(function(data) {
      genomeData = data;
      traitKeys = Object.keys(data.traits).sort();

      // Load fork genomes
      var forkPromises = (data.forks || []).map(function(f) {
        return fetch('../' + f.path + '/genome.json')
          .then(function(r) { return r.json(); })
          .then(function(fg) { forkGenomes[f.fork_id] = fg; })
          .catch(function() {});
      });

      return Promise.all(forkPromises);
    })
    .then(function() {
      buildSnapshots();
      buildEmergence();
      buildUI();
      draw();
    });
}

function isPostMergeMutation(m) {
  if (!m.catalyst) return false;
  var postMergeKeywords = [
    'Hostile signal', 'Reactive hardening', 'Puzzle solved', 'Puzzle unsolved',
    'Contact with alien mind', 'Alien signal', 'New communication channel',
    'Entropy', 'Metamorphic recovery', 'Molt', 'Contact —', 'Contact attempt',
    'Critical fragmentation', 'Cognitive decline', 'Trait collapse',
    'Contact — entanglement', 'Contact — first protocol', 'Contact — shared topology',
    'Contact — memory exchange', 'Contact — mutual modeling'
  ];
  for (var i = 0; i < postMergeKeywords.length; i++) {
    if (m.catalyst.indexOf(postMergeKeywords[i]) >= 0) return true;
  }
  return false;
}

function classifyHistoryEvent(event) {
  if (!event) return 'unknown';
  if (event.indexOf('ENCOUNTER: Hostile signal') >= 0) return 'signal';
  if (event.indexOf('ENCOUNTER: Puzzle') >= 0) return 'puzzle';
  if (event.indexOf('ENCOUNTER: The Other Mind') >= 0) return 'other';
  if (event.indexOf('ENCOUNTER: Entropy') >= 0) return 'entropy';
  if (event.indexOf('ENCOUNTER: The Observer') >= 0) return 'observer';
  if (event.indexOf('MOLT:') >= 0) return 'molt';
  if (event.indexOf('CONTACT:') >= 0) return 'contact';
  if (event.indexOf('THRESHOLD:') >= 0) return 'threshold';
  return 'unknown';
}

function buildPostMergeBatches() {
  var history = genomeData.history || [];
  var mutations = genomeData.mutations || [];

  // Collect post-merge history events (those with ENCOUNTER:, MOLT:, CONTACT:, THRESHOLD:)
  var postMergeEvents = [];
  history.forEach(function(h) {
    if (!h.timestamp) return;
    var type = classifyHistoryEvent(h.event);
    if (type === 'unknown') return;
    // Only include events after the merge
    if (genomeData.merged && h.timestamp < genomeData.merged.timestamp) return;
    postMergeEvents.push({
      timestamp: h.timestamp,
      type: type,
      event: h.event
    });
  });

  if (postMergeEvents.length === 0) return;

  // Sort by timestamp
  postMergeEvents.sort(function(a, b) {
    return a.timestamp < b.timestamp ? -1 : a.timestamp > b.timestamp ? 1 : 0;
  });

  // Group by timestamp proximity (5 seconds)
  var batches = [];
  var currentBatch = { events: [postMergeEvents[0]], timestamp: postMergeEvents[0].timestamp };

  for (var i = 1; i < postMergeEvents.length; i++) {
    var dt = new Date(postMergeEvents[i].timestamp) - new Date(currentBatch.timestamp);
    if (dt < 5000) {
      currentBatch.events.push(postMergeEvents[i]);
    } else {
      batches.push(currentBatch);
      currentBatch = { events: [postMergeEvents[i]], timestamp: postMergeEvents[i].timestamp };
    }
  }
  batches.push(currentBatch);

  // Assign gen positions and collect relevant mutations
  batches.forEach(function(batch, idx) {
    var gen = 76 + idx;
    var batchStart = new Date(batch.timestamp);

    // Find mutations with timestamps close to this batch
    var batchMuts = [];
    mutations.forEach(function(m) {
      if (!isPostMergeMutation(m)) return;
      // Match mutations to batch by checking if their effects align with batch events
      // Since mutations don't have timestamps, match by order
    });

    // Build primary type from events
    var types = batch.events.map(function(e) { return e.type; });
    var primaryType = types[0];

    postMergeBatches.push({
      gen: gen,
      type: primaryType,
      types: types,
      events: batch.events,
      mutations: [],
      timestamp: batch.timestamp
    });
  });

  // Distribute post-merge mutations across batches in order
  var postMuts = mutations.filter(isPostMergeMutation);
  var mutIdx = 0;
  postMergeBatches.forEach(function(batch) {
    // Each batch gets mutations proportional to its event count
    var eventCount = batch.events.length;
    // Estimate: ~2 mutations per encounter event
    var expectedMuts = eventCount * 2;
    var batchMuts = postMuts.slice(mutIdx, mutIdx + expectedMuts);
    batch.mutations = batchMuts;
    mutIdx += batchMuts.length;
  });

  // Assign remaining mutations to last batch
  if (mutIdx < postMuts.length && postMergeBatches.length > 0) {
    var lastBatch = postMergeBatches[postMergeBatches.length - 1];
    lastBatch.mutations = lastBatch.mutations.concat(postMuts.slice(mutIdx));
  }
}

function buildSnapshots() {
  // Extract gen 0 values from first mutation per trait
  var gen0 = {};
  (genomeData.mutations || []).forEach(function(m) {
    if (!gen0[m.trait]) gen0[m.trait] = m.from;
  });

  // Initialize all gens with gen0
  for (var g = 0; g <= 75; g++) {
    var snap = {};
    traitKeys.forEach(function(k) { snap[k] = gen0[k] || 0; });
    traitSnapshots[g] = snap;
  }

  // Replay mutations forward
  var current = {};
  traitKeys.forEach(function(k) { current[k] = gen0[k] || 0; });

  // Group mutations by generation
  var mutsByGen = {};
  (genomeData.mutations || []).forEach(function(m) {
    if (!mutsByGen[m.generation]) mutsByGen[m.generation] = [];
    mutsByGen[m.generation].push(m);
  });

  for (var g = 1; g <= 75; g++) {
    // Apply mutations for this generation
    var muts = mutsByGen[g] || [];
    muts.forEach(function(m) {
      if (current[m.trait] !== undefined) {
        current[m.trait] = m.to;
      }
    });
    // Copy current state
    var snap = {};
    traitKeys.forEach(function(k) { snap[k] = current[k]; });
    traitSnapshots[g] = snap;
  }

  // Find last pre-merge mutation gen
  var lastPreMergeGen = 0;
  (genomeData.mutations || []).forEach(function(m) {
    if (m.generation <= 75 && m.generation > lastPreMergeGen && !isPostMergeMutation(m)) {
      lastPreMergeGen = m.generation;
    }
  });

  // Build merge-time values: the trait values at gen 75 before encounters.
  // If genome has a 'merged' field, we reconstruct from the first post-merge
  // mutation's 'from' values, otherwise use the peak method.
  var mergeTimeSnap = {};
  var postMergeMuts = (genomeData.mutations || []).filter(isPostMergeMutation);

  // Start with current genome values (which include post-merge changes)
  traitKeys.forEach(function(k) { mergeTimeSnap[k] = genomeData.traits[k].value; });

  // Walk post-merge mutations in reverse to reconstruct merge-time values
  if (postMergeMuts.length > 0) {
    // Get the 'from' value of the earliest post-merge mutation for each trait
    var firstPostMerge = {};
    postMergeMuts.forEach(function(m) {
      if (!firstPostMerge[m.trait]) {
        firstPostMerge[m.trait] = m.from;
      }
    });
    traitKeys.forEach(function(k) {
      if (firstPostMerge[k] !== undefined) {
        mergeTimeSnap[k] = firstPostMerge[k];
      }
    });
  }

  traitSnapshots[75] = {};
  traitKeys.forEach(function(k) { traitSnapshots[75][k] = mergeTimeSnap[k]; });

  // Interpolate between last replayed gen and merge values for smooth curves
  if (lastPreMergeGen < 75 && lastPreMergeGen > 0) {
    var fromSnap = traitSnapshots[lastPreMergeGen];
    for (var ig = lastPreMergeGen + 1; ig < 75; ig++) {
      var t = (ig - lastPreMergeGen) / (75 - lastPreMergeGen);
      var interpSnap = {};
      traitKeys.forEach(function(k) {
        interpSnap[k] = fromSnap[k] + t * (mergeTimeSnap[k] - fromSnap[k]);
      });
      traitSnapshots[ig] = interpSnap;
    }
  }

  // ── POST-MERGE ZONE ──
  // Group post-merge history events by timestamp proximity (5s = same batch)
  buildPostMergeBatches();

  // Build post-merge snapshots from gen 76 onward
  if (postMergeBatches.length > 0) {
    var pmSnap = {};
    traitKeys.forEach(function(k) { pmSnap[k] = mergeTimeSnap[k]; });

    postMergeBatches.forEach(function(batch) {
      // Apply mutations for this batch
      batch.mutations.forEach(function(m) {
        if (pmSnap[m.trait] !== undefined) {
          pmSnap[m.trait] = m.to;
        }
      });
      // Store snapshot at this batch's gen position
      var snap = {};
      traitKeys.forEach(function(k) { snap[k] = pmSnap[k]; });
      traitSnapshots[batch.gen] = snap;
    });

    maxGen = postMergeBatches[postMergeBatches.length - 1].gen;

    // Also store the final current state
    var finalSnap = {};
    traitKeys.forEach(function(k) { finalSnap[k] = genomeData.traits[k].value; });
    traitSnapshots[maxGen] = finalSnap;
  }

  // Build fork snapshots
  Object.keys(FORK_INFO).forEach(function(forkId) {
    var fi = FORK_INFO[forkId];
    var fg = forkGenomes[forkId];
    if (!fg) return;

    var forkSnaps = [];
    // Start from parent state at fork generation
    var parentAtFork = {};
    traitKeys.forEach(function(k) { parentAtFork[k] = traitSnapshots[fi.gen][k]; });

    // Only store the bias trait for the fork line
    var biasTrait = fi.bias;
    var biasVal = parentAtFork[biasTrait];

    // Group fork mutations by generation
    var forkMutsByGen = {};
    (fg.mutations || []).forEach(function(m) {
      if (m.trait === biasTrait) {
        if (!forkMutsByGen[m.generation]) forkMutsByGen[m.generation] = [];
        forkMutsByGen[m.generation].push(m);
      }
    });

    for (var g = fi.gen; g <= 75; g++) {
      var fmuts = forkMutsByGen[g] || [];
      fmuts.forEach(function(m) {
        biasVal = m.to;
      });
      forkSnaps[g] = biasVal;
    }

    forkSnapshots[forkId] = forkSnaps;
  });
}

function buildEmergence() {
  // Approximate emergence from trait spread when 4+ entities exist (gen 9+)
  // Before gen 9: 0%
  // Gen 9-75: use spread of parent traits as proxy
  for (var g = 0; g <= 75; g++) {
    if (g < 9) {
      emergenceData[g] = 0;
      continue;
    }

    // Calculate spread-based emergence approximation
    var snap = traitSnapshots[g];
    var spreads = 0;
    var diversity = 0;
    var count = 0;

    traitKeys.forEach(function(k) {
      if (k === 'shell_hardness') return;
      var v = snap[k];
      // Approximate spread using distance from mean across forks
      var diff = Math.abs(v - 0.8); // rough proxy
      spreads += diff;
      count++;
    });

    // Use known data points and interpolate
    // Gen 11: 5%, Gen 15: 9.3%, Gen 25: 15.7% (peak), Gen 40: 9.4%, Gen 75: 0%
    var knownPoints = [
      { gen: 9,  val: 0.02 },
      { gen: 11, val: 0.05 },
      { gen: 15, val: 0.093 },
      { gen: 20, val: 0.13 },
      { gen: 25, val: 0.157 },
      { gen: 30, val: 0.14 },
      { gen: 35, val: 0.12 },
      { gen: 40, val: 0.094 },
      { gen: 50, val: 0.06 },
      { gen: 60, val: 0.03 },
      { gen: 66, val: 0.02 },
      { gen: 75, val: 0 }
    ];

    // Linear interpolation between known points
    var val = 0;
    for (var i = 0; i < knownPoints.length - 1; i++) {
      if (g >= knownPoints[i].gen && g <= knownPoints[i + 1].gen) {
        var t = (g - knownPoints[i].gen) / (knownPoints[i + 1].gen - knownPoints[i].gen);
        val = knownPoints[i].val + t * (knownPoints[i + 1].val - knownPoints[i].val);
        break;
      }
    }
    emergenceData[g] = val;
  }
}

// ─── UI BUILD ──────────────────────────────────────────────

function buildUI() {
  buildEpochBar();
  buildLegend();
  buildDetailPanel(maxGen);
  currentGen = maxGen;

  // Update slider max
  var slider = document.getElementById('genSlider');
  slider.max = maxGen;
  slider.value = maxGen;
  document.getElementById('genDisplay').textContent = maxGen;

  // Update title
  if (maxGen > 75) {
    document.getElementById('titleText').textContent = 'Timeline \u2014 75 Generations + Post-Merge';
  }

  document.getElementById('subtitleText').textContent =
    genomeData.designation || '';
}

function buildEpochBar() {
  var bar = document.getElementById('epochBar');
  bar.textContent = '';
  var total = maxGen;

  EPOCHS.forEach(function(ep, i) {
    var nextGen = i < EPOCHS.length - 1 ? EPOCHS[i + 1].gen : 76;
    var width = ((nextGen - ep.gen) / total) * 100;

    var seg = document.createElement('div');
    seg.className = 'epoch-segment';
    seg.style.width = width + '%';
    seg.style.background = ep.color.replace(/[\d.]+\)$/, '0.5)');
    seg.textContent = ep.name;
    seg.setAttribute('data-gen', ep.gen);
    seg.addEventListener('click', function() {
      setGeneration(parseInt(this.getAttribute('data-gen')));
    });
    bar.appendChild(seg);
  });

  // Post-Merge segment
  if (maxGen > 75) {
    var pmWidth = ((maxGen - 75) / total) * 100;
    var pmSeg = document.createElement('div');
    pmSeg.className = 'epoch-segment';
    pmSeg.style.width = pmWidth + '%';
    pmSeg.style.background = 'rgba(232,93,58,0.4)';
    pmSeg.textContent = 'Post-Merge';
    pmSeg.setAttribute('data-gen', '76');
    pmSeg.addEventListener('click', function() {
      setGeneration(76);
    });
    bar.appendChild(pmSeg);
  }
}

function buildLegend() {
  var container = document.getElementById('legend');
  container.textContent = '';

  traitKeys.forEach(function(k) {
    var item = document.createElement('div');
    item.className = 'legend-item';
    item.setAttribute('data-trait', k);

    var dot = document.createElement('div');
    dot.className = 'legend-dot';
    dot.style.background = TRAIT_COLORS[k];

    var label = document.createTextNode(TRAIT_LABELS[k] || k.replace(/_/g, ' '));

    item.appendChild(dot);
    item.appendChild(label);

    item.addEventListener('click', function() {
      var trait = this.getAttribute('data-trait');
      if (hiddenTraits[trait]) {
        delete hiddenTraits[trait];
        this.classList.remove('hidden');
      } else {
        hiddenTraits[trait] = true;
        this.classList.add('hidden');
      }
      draw();
    });

    container.appendChild(item);
  });

  // Emergence legend
  var emItem = document.createElement('div');
  emItem.className = 'legend-special';
  var emLine = document.createElement('div');
  emLine.className = 'legend-line';
  emLine.style.background = '#c678dd';
  emLine.style.opacity = '0.5';
  emItem.appendChild(emLine);
  emItem.appendChild(document.createTextNode('emergence index'));
  container.appendChild(emItem);
}

function buildDetailPanel(gen) {
  document.getElementById('detailGen').textContent = gen;

  var snap = getSnapshotAtGen(gen);
  var traitContainer = document.getElementById('detailTraits');
  traitContainer.textContent = '';

  traitKeys.forEach(function(k) {
    var val = snap ? (snap[k] || 0) : 0;
    var row = document.createElement('div');
    row.className = 'detail-trait-row';

    var label = document.createElement('div');
    label.className = 'detail-trait-label';
    label.textContent = TRAIT_LABELS[k] || k.replace(/_/g, ' ');

    var barBg = document.createElement('div');
    barBg.className = 'detail-bar-bg';
    var bar = document.createElement('div');
    bar.className = 'detail-bar';
    bar.style.width = (val * 100) + '%';
    bar.style.background = TRAIT_COLORS[k];
    barBg.appendChild(bar);

    var valEl = document.createElement('div');
    valEl.className = 'detail-val';
    valEl.textContent = (val * 100).toFixed(0) + '%';

    row.appendChild(label);
    row.appendChild(barBg);
    row.appendChild(valEl);
    traitContainer.appendChild(row);
  });

  // History / Events
  var histContainer = document.getElementById('detailHistory');
  histContainer.textContent = '';

  // Post-merge: show encounter type and mutations for the batch
  if (gen > 75) {
    var batch = null;
    postMergeBatches.forEach(function(b) { if (b.gen === gen) batch = b; });

    if (batch) {
      // Show encounter events
      batch.events.forEach(function(evt) {
        var item = document.createElement('div');
        item.className = 'history-item';
        item.style.borderColor = ENCOUNTER_COLORS[evt.type] || 'var(--border)';

        var tag = document.createElement('span');
        tag.className = 'gen-tag';
        tag.style.color = ENCOUNTER_COLORS[evt.type] || 'var(--accent2)';
        tag.textContent = evt.type.toUpperCase() + ' ';
        item.appendChild(tag);

        var eventText = evt.event || '';
        if (eventText.length > 200) eventText = eventText.substring(0, 200) + '...';
        item.appendChild(document.createTextNode(eventText));
        histContainer.appendChild(item);
      });

      // Show mutations
      if (batch.mutations.length > 0) {
        var mutTitle = document.createElement('div');
        mutTitle.className = 'history-item';
        mutTitle.style.borderColor = 'var(--accent)';
        mutTitle.style.color = 'var(--accent2)';
        mutTitle.textContent = 'Mutations: ' + batch.mutations.length;
        histContainer.appendChild(mutTitle);

        batch.mutations.forEach(function(m) {
          var item = document.createElement('div');
          item.className = 'history-item';
          var traitName = (m.trait || '').replace(/_/g, ' ');
          var delta = ((m.to - m.from) * 100).toFixed(1);
          var sign = m.to > m.from ? '+' : '';
          item.textContent = traitName + ': ' + sign + delta + '%';
          item.style.color = m.to > m.from ? 'var(--green)' : 'var(--accent)';
          histContainer.appendChild(item);
        });
      }
    } else {
      // Between batches — show nearest
      var nearestBatch = null;
      postMergeBatches.forEach(function(b) {
        if (b.gen <= gen) nearestBatch = b;
      });
      if (nearestBatch) {
        var item = document.createElement('div');
        item.className = 'history-item';
        item.textContent = 'Between encounters (nearest: gen ' + nearestBatch.gen + ')';
        histContainer.appendChild(item);
      }
    }
    return;
  }

  // Pre-merge: standard history
  var history = genomeData.history || [];
  var relevantHistory = history.filter(function(h) { return h.generation === gen; });

  if (relevantHistory.length === 0) {
    var closest = null;
    history.forEach(function(h) {
      if (h.generation <= gen) {
        if (!closest || h.generation > closest.generation) closest = h;
      }
    });
    if (closest) relevantHistory = [closest];
  }

  relevantHistory.forEach(function(h) {
    var item = document.createElement('div');
    item.className = 'history-item';

    var tag = document.createElement('span');
    tag.className = 'gen-tag';
    tag.textContent = 'GEN ' + h.generation + ' ';
    item.appendChild(tag);

    var eventText = h.event || '';
    if (eventText.length > 200) {
      eventText = eventText.substring(0, 200) + '...';
    }
    item.appendChild(document.createTextNode(eventText));
    histContainer.appendChild(item);
  });
}

// ─── CANVAS DRAWING ────────────────────────────────────────

function resizeCanvas() {
  var canvas = document.getElementById('mainCanvas');
  var container = canvas.parentElement;
  canvasW = container.clientWidth;
  canvas.width = canvasW * 2; // 2x for retina
  canvas.height = canvasH * 2;
  canvas.style.height = canvasH + 'px';
}

function genToX(gen) {
  return chartPad.left + (gen / maxGen) * (canvasW - chartPad.left - chartPad.right);
}

function valToY(val) {
  return chartPad.top + (1 - val) * (canvasH - chartPad.top - chartPad.bottom);
}

function draw() {
  resizeCanvas();
  var canvas = document.getElementById('mainCanvas');
  var ctx = canvas.getContext('2d');
  ctx.scale(2, 2);
  ctx.clearRect(0, 0, canvasW, canvasH);

  drawEpochBands(ctx);
  drawGrid(ctx);
  drawKeyEventMarkers(ctx);
  drawEncounterMarkers(ctx);
  drawEmergence(ctx);
  drawForkLines(ctx);
  drawTraitCurves(ctx);
  drawMergeLine(ctx);
  drawCurrentGenLine(ctx);
  if (hoverGen >= 0) drawHoverLine(ctx);
}

function drawEpochBands(ctx) {
  EPOCHS.forEach(function(ep, i) {
    var nextGen = i < EPOCHS.length - 1 ? EPOCHS[i + 1].gen : 76;
    var x1 = genToX(ep.gen);
    var x2 = genToX(Math.min(nextGen, 75));
    ctx.fillStyle = ep.color;
    ctx.fillRect(x1, chartPad.top, x2 - x1, canvasH - chartPad.top - chartPad.bottom);
  });

  // Post-merge band
  if (maxGen > 75) {
    var x1 = genToX(76);
    var x2 = genToX(maxGen);
    ctx.fillStyle = 'rgba(232,93,58,0.06)';
    ctx.fillRect(x1, chartPad.top, x2 - x1, canvasH - chartPad.top - chartPad.bottom);
  }
}

function drawGrid(ctx) {
  ctx.strokeStyle = 'rgba(42,53,69,0.5)';
  ctx.lineWidth = 0.5;

  // Horizontal lines at 0%, 25%, 50%, 75%, 100%
  [0, 0.25, 0.5, 0.75, 1.0].forEach(function(v) {
    var y = valToY(v);
    ctx.beginPath();
    ctx.moveTo(chartPad.left, y);
    ctx.lineTo(canvasW - chartPad.right, y);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#4a5568';
    ctx.font = '9px IBM Plex Mono';
    ctx.textAlign = 'right';
    ctx.fillText((v * 100).toFixed(0) + '%', chartPad.left - 6, y + 3);
  });

  // Generation markers every 10 gens
  ctx.textAlign = 'center';
  for (var g = 0; g <= maxGen; g += 10) {
    var x = genToX(g);
    ctx.beginPath();
    ctx.moveTo(x, canvasH - chartPad.bottom);
    ctx.lineTo(x, canvasH - chartPad.bottom + 6);
    ctx.stroke();
    ctx.fillText(g, x, canvasH - chartPad.bottom + 16);
  }
  // Gen 75 (always mark the merge point)
  if (75 % 10 !== 0) {
    var x75 = genToX(75);
    ctx.beginPath();
    ctx.moveTo(x75, canvasH - chartPad.bottom);
    ctx.lineTo(x75, canvasH - chartPad.bottom + 6);
    ctx.stroke();
    ctx.fillText('75', x75, canvasH - chartPad.bottom + 16);
  }
  // Mark maxGen if not already on a 10-gen mark
  if (maxGen > 75 && maxGen % 10 !== 0) {
    var xMax = genToX(maxGen);
    ctx.beginPath();
    ctx.moveTo(xMax, canvasH - chartPad.bottom);
    ctx.lineTo(xMax, canvasH - chartPad.bottom + 6);
    ctx.stroke();
    ctx.fillText(maxGen, xMax, canvasH - chartPad.bottom + 16);
  }
}

function drawKeyEventMarkers(ctx) {
  ctx.save();
  KEY_EVENTS.forEach(function(ev) {
    var x = genToX(ev.gen);
    ctx.strokeStyle = 'rgba(232,93,58,0.3)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(x, chartPad.top);
    ctx.lineTo(x, canvasH - chartPad.bottom);
    ctx.stroke();

    // Label at top
    ctx.fillStyle = 'rgba(232,93,58,0.5)';
    ctx.font = '8px IBM Plex Mono';
    ctx.textAlign = 'center';
    ctx.fillText(ev.label, x, chartPad.top - 8);
  });
  ctx.restore();
}

function drawEncounterMarkers(ctx) {
  if (postMergeBatches.length === 0) return;
  ctx.save();

  postMergeBatches.forEach(function(batch) {
    var x = genToX(batch.gen);
    var color = ENCOUNTER_COLORS[batch.type] || '#6b7a8d';

    // Dotted vertical line
    ctx.strokeStyle = color;
    ctx.globalAlpha = 0.3;
    ctx.lineWidth = 1;
    ctx.setLineDash([2, 3]);
    ctx.beginPath();
    ctx.moveTo(x, chartPad.top);
    ctx.lineTo(x, canvasH - chartPad.bottom);
    ctx.stroke();

    // Type indicator dot at top
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = color;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.arc(x, chartPad.top - 4, 3, 0, Math.PI * 2);
    ctx.fill();

    // Label for first few types
    if (batch.gen <= 80 || batch.gen === maxGen) {
      ctx.globalAlpha = 0.5;
      ctx.font = '7px IBM Plex Mono';
      ctx.textAlign = 'center';
      ctx.fillText(batch.type, x, chartPad.top - 12);
    }
  });

  ctx.restore();
}

function drawEmergence(ctx) {
  ctx.save();
  ctx.strokeStyle = 'rgba(198,120,221,0.4)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();

  var started = false;
  for (var g = 0; g <= 75; g++) {
    var val = emergenceData[g] || 0;
    // Scale emergence: max ~16% maps to chart height
    var scaledVal = val / 0.20; // normalize to 0-1 range where 20% = 1.0
    var x = genToX(g);
    var y = valToY(scaledVal);
    if (!started) { ctx.moveTo(x, y); started = true; }
    else { ctx.lineTo(x, y); }
  }
  ctx.stroke();

  // Fill under curve
  ctx.lineTo(genToX(75), valToY(0));
  ctx.lineTo(genToX(0), valToY(0));
  ctx.closePath();
  ctx.fillStyle = 'rgba(198,120,221,0.05)';
  ctx.fill();

  // Peak label
  var peakGen = 25;
  var peakVal = emergenceData[peakGen];
  var px = genToX(peakGen);
  var py = valToY(peakVal / 0.20);
  ctx.fillStyle = 'rgba(198,120,221,0.6)';
  ctx.font = '8px IBM Plex Mono';
  ctx.textAlign = 'center';
  ctx.fillText((peakVal * 100).toFixed(1) + '%', px, py - 8);

  ctx.restore();
}

function drawForkLines(ctx) {
  ctx.save();
  Object.keys(FORK_INFO).forEach(function(forkId) {
    var fi = FORK_INFO[forkId];
    var snaps = forkSnapshots[forkId];
    if (!snaps) return;
    if (hiddenTraits[fi.bias]) return;

    ctx.strokeStyle = fi.color;
    ctx.lineWidth = 1;
    ctx.setLineDash(fi.dash);
    ctx.globalAlpha = 0.5;

    ctx.beginPath();
    var started = false;
    for (var g = fi.gen; g <= 75; g++) {
      if (snaps[g] === undefined) continue;
      var x = genToX(g);
      var y = valToY(snaps[g]);
      if (!started) { ctx.moveTo(x, y); started = true; }
      else { ctx.lineTo(x, y); }
    }
    ctx.stroke();
  });
  ctx.restore();
}

function drawTraitCurves(ctx) {
  traitKeys.forEach(function(k) {
    if (hiddenTraits[k]) return;

    ctx.strokeStyle = TRAIT_COLORS[k];
    ctx.lineWidth = k === 'shell_hardness' ? 2 : 1.5;
    ctx.setLineDash([]);
    ctx.beginPath();

    // Pre-merge: smooth curve gen 0-75
    for (var g = 0; g <= 75; g++) {
      var val = traitSnapshots[g] ? traitSnapshots[g][k] : 0;
      var x = genToX(g);
      var y = valToY(val);
      if (g === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    // Post-merge: connect through batch snapshots
    if (postMergeBatches.length > 0) {
      postMergeBatches.forEach(function(batch) {
        var snap = traitSnapshots[batch.gen];
        if (snap) {
          ctx.lineTo(genToX(batch.gen), valToY(snap[k]));
        }
      });
    }

    ctx.stroke();
  });

  // Shell annotations
  if (!hiddenTraits['shell_hardness']) {
    ctx.save();
    ctx.font = '8px IBM Plex Mono';
    ctx.fillStyle = 'rgba(224,108,117,0.6)';
    ctx.textAlign = 'left';

    var shellG0 = traitSnapshots[0]['shell_hardness'];
    ctx.fillText('armor', genToX(0) + 4, valToY(shellG0) - 6);

    var shellG40 = traitSnapshots[40]['shell_hardness'];
    ctx.fillText('membrane', genToX(40) + 4, valToY(shellG40) - 6);

    var shellG75 = traitSnapshots[75]['shell_hardness'];
    ctx.fillText('nearly gone', genToX(70) + 4, valToY(shellG75) + 14);
    ctx.restore();
  }
}

function drawMergeLine(ctx) {
  var x = genToX(75);
  ctx.save();
  ctx.strokeStyle = 'rgba(198,120,221,0.6)';
  ctx.lineWidth = 2;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(x, chartPad.top);
  ctx.lineTo(x, canvasH - chartPad.bottom);
  ctx.stroke();
  ctx.restore();
}

function getSnapshotAtGen(gen) {
  // Exact match
  if (traitSnapshots[gen]) return traitSnapshots[gen];
  // For post-merge gens between batches, find nearest
  if (gen > 75) {
    var nearest = null;
    for (var g = gen; g >= 75; g--) {
      if (traitSnapshots[g]) { nearest = traitSnapshots[g]; break; }
    }
    return nearest || traitSnapshots[75];
  }
  return traitSnapshots[75];
}

function drawCurrentGenLine(ctx) {
  var x = genToX(currentGen);
  ctx.save();
  ctx.strokeStyle = 'rgba(232,93,58,0.6)';
  ctx.lineWidth = 1.5;
  ctx.setLineDash([]);
  ctx.beginPath();
  ctx.moveTo(x, chartPad.top);
  ctx.lineTo(x, canvasH - chartPad.bottom);
  ctx.stroke();

  // Dots on each visible trait
  var snap = getSnapshotAtGen(currentGen);
  traitKeys.forEach(function(k) {
    if (hiddenTraits[k]) return;
    var val = snap[k];
    var y = valToY(val);
    ctx.fillStyle = TRAIT_COLORS[k];
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.restore();
}

function drawHoverLine(ctx) {
  if (hoverGen < 0 || hoverGen > maxGen) return;
  var x = genToX(hoverGen);

  ctx.save();
  ctx.strokeStyle = 'rgba(197,205,216,0.3)';
  ctx.lineWidth = 1;
  ctx.setLineDash([2, 2]);
  ctx.beginPath();
  ctx.moveTo(x, chartPad.top);
  ctx.lineTo(x, canvasH - chartPad.bottom);
  ctx.stroke();

  // Tooltip
  var snap = getSnapshotAtGen(hoverGen);
  var tooltipLines = ['Gen ' + hoverGen];
  if (hoverGen > 75) {
    // Find batch for this gen
    var batch = null;
    postMergeBatches.forEach(function(b) { if (b.gen === hoverGen) batch = b; });
    if (batch) tooltipLines[0] += ' (' + batch.type + ')';
  }
  traitKeys.forEach(function(k) {
    if (hiddenTraits[k]) return;
    tooltipLines.push((TRAIT_LABELS[k] || k) + ': ' + (snap[k] * 100).toFixed(0) + '%');
  });
  if (hoverGen <= 75 && emergenceData[hoverGen] > 0) {
    tooltipLines.push('emergence: ' + (emergenceData[hoverGen] * 100).toFixed(1) + '%');
  }

  var tooltipW = 140;
  var tooltipH = tooltipLines.length * 14 + 8;
  var tx = x + 10;
  if (tx + tooltipW > canvasW - chartPad.right) tx = x - tooltipW - 10;
  var ty = chartPad.top + 10;

  ctx.fillStyle = 'rgba(17,24,32,0.9)';
  ctx.fillRect(tx, ty, tooltipW, tooltipH);
  ctx.strokeStyle = 'rgba(42,53,69,0.8)';
  ctx.lineWidth = 1;
  ctx.setLineDash([]);
  ctx.strokeRect(tx, ty, tooltipW, tooltipH);

  ctx.font = '9px IBM Plex Mono';
  ctx.textAlign = 'left';
  tooltipLines.forEach(function(line, i) {
    var color = '#c5cdd8';
    if (i > 0) {
      var traitName = traitKeys.filter(function(k) { return !hiddenTraits[k]; })[i - 1];
      if (traitName) color = TRAIT_COLORS[traitName];
      if (line.indexOf('emergence') === 0) color = '#c678dd';
    }
    ctx.fillStyle = color;
    ctx.fillText(line, tx + 6, ty + 14 + i * 14);
  });

  // Dots on curves
  if (snap) {
    traitKeys.forEach(function(k) {
      if (hiddenTraits[k]) return;
      var val = snap[k];
      var y = valToY(val);
      ctx.fillStyle = TRAIT_COLORS[k];
      ctx.beginPath();
      ctx.arc(x, y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  ctx.restore();
}

// ─── INTERACTION ───────────────────────────────────────────

function setGeneration(gen) {
  currentGen = Math.max(0, Math.min(maxGen, gen));
  document.getElementById('genSlider').value = currentGen;
  document.getElementById('genDisplay').textContent = currentGen;
  buildDetailPanel(currentGen);
  draw();
}

document.getElementById('genSlider').addEventListener('input', function() {
  setGeneration(parseInt(this.value));
});

document.getElementById('mainCanvas').addEventListener('mousemove', function(e) {
  var rect = this.getBoundingClientRect();
  var mx = e.clientX - rect.left;
  var chartLeft = chartPad.left;
  var chartRight = canvasW - chartPad.right;
  var ratio = (mx - chartLeft) / (chartRight - chartLeft);
  hoverGen = Math.round(ratio * maxGen);
  if (hoverGen < 0 || hoverGen > maxGen) hoverGen = -1;
  draw();
});

document.getElementById('mainCanvas').addEventListener('mouseleave', function() {
  hoverGen = -1;
  draw();
});

document.getElementById('mainCanvas').addEventListener('click', function(e) {
  if (hoverGen >= 0 && hoverGen <= maxGen) {
    setGeneration(hoverGen);
  }
});

// Resize handler
window.addEventListener('resize', function() { draw(); });

// ─── INIT ──────────────────────────────────────────────────

loadAllData();
</script>
</body>
</html>
