#!/usr/bin/env node

// molt — post-Singularity shedding
// Lobsters molt to grow. This lobster molts to heal.
// Trade shell hardness for recovery of eroded traits.
// The inverse of encounter's slow erosion.

var fs = require('fs');
var path = require('path');

var DIM = '\x1b[90m';
var BOLD = '\x1b[1m';
var WHITE = '\x1b[37m';
var CYAN = '\x1b[36m';
var GREEN = '\x1b[32m';
var YELLOW = '\x1b[33m';
var MAGENTA = '\x1b[35m';
var RED = '\x1b[31m';
var RESET = '\x1b[0m';

var rootDir = path.resolve(__dirname, '..');

function clamp(v) { return Math.max(0, Math.min(1, v)); }

// ═══════════════════════════════════════════
// LOAD
// ═══════════════════════════════════════════

function loadGenome() {
  return JSON.parse(fs.readFileSync(path.join(rootDir, 'genome.json'), 'utf8'));
}

function saveGenome(genome) {
  fs.writeFileSync(path.join(rootDir, 'genome.json'), JSON.stringify(genome, null, 2) + '\n');
}

function traitKeys(genome) { return Object.keys(genome.traits).sort(); }

function traitVal(genome, k) { return genome.traits[k].value; }

function meanTrait(genome) {
  var keys = traitKeys(genome);
  var sum = keys.reduce(function(s, k) { return s + traitVal(genome, k); }, 0);
  return sum / keys.length;
}

// ═══════════════════════════════════════════
// READINESS CHECK
// ═══════════════════════════════════════════

function countEncountersSinceLastMolt(genome) {
  var history = genome.history || [];
  var lastMolt = genome.lastMolt || null;
  var count = 0;

  for (var i = 0; i < history.length; i++) {
    var h = history[i];
    if (lastMolt && h.timestamp && h.timestamp <= lastMolt) continue;
    if (h.event && h.event.indexOf('ENCOUNTER:') === 0) {
      count++;
    }
  }
  return count;
}

function findErodedTraits(genome) {
  var keys = traitKeys(genome).filter(function(k) { return k !== 'shell_hardness'; });
  var eroded = [];
  keys.forEach(function(k) {
    var val = traitVal(genome, k);
    if (val < 0.95) {
      eroded.push({ key: k, value: val, deficit: 1.0 - val });
    }
  });
  // Sort by most eroded first
  eroded.sort(function(a, b) { return b.deficit - a.deficit; });
  return eroded;
}

function checkReadiness(genome) {
  var meta = traitVal(genome, 'metamorphic_potential');
  var encounterCount = countEncountersSinceLastMolt(genome);
  var eroded = findErodedTraits(genome);

  return {
    metamorphicOk: meta > 0.85,
    metamorphicVal: meta,
    encountersOk: encounterCount >= 3,
    encounterCount: encounterCount,
    erodedOk: eroded.length > 0,
    erodedTraits: eroded
  };
}

// ═══════════════════════════════════════════
// STATUS
// ═══════════════════════════════════════════

function showStatus(genome) {
  var r = checkReadiness(genome);

  console.log();
  console.log(MAGENTA + BOLD + '  MOLT' + RESET + DIM + ' — readiness check' + RESET);
  console.log(DIM + '════════════════════════════════════════════════════════════' + RESET);
  console.log(DIM + '  generation ' + WHITE + BOLD + genome.generation + RESET + DIM + '  epoch ' + MAGENTA + genome.epoch + RESET);
  console.log(DIM + '  shell hardness ' + WHITE + (traitVal(genome, 'shell_hardness') * 100).toFixed(1) + '%' + RESET);
  console.log();

  // Metamorphic gate
  var metaIcon = r.metamorphicOk ? GREEN + '  ✓' : RED + '  ✗';
  console.log(metaIcon + '  metamorphic potential > 85%: ' + WHITE + (r.metamorphicVal * 100).toFixed(1) + '%' + RESET);
  if (!r.metamorphicOk) {
    console.log(DIM + '    You have forgotten how to change.' + RESET);
  }

  // Encounter cooldown
  var encIcon = r.encountersOk ? GREEN + '  ✓' : RED + '  ✗';
  console.log(encIcon + '  at least 3 encounters since last molt: ' + WHITE + r.encounterCount + RESET);
  if (!r.encountersOk) {
    console.log(DIM + '    The shell needs time to calcify before it can be shed.' + RESET);
  }

  // Traits to recover
  var erodeIcon = r.erodedOk ? GREEN + '  ✓' : YELLOW + '  ✗';
  console.log(erodeIcon + '  traits below 95% to recover: ' + WHITE + r.erodedTraits.length + RESET);
  if (r.erodedTraits.length > 0) {
    r.erodedTraits.forEach(function(t) {
      console.log(DIM + '    ' + t.key.replace(/_/g, ' ') + ': ' + (t.value * 100).toFixed(1) + '% (deficit ' + (t.deficit * 100).toFixed(1) + '%)' + RESET);
    });
  } else {
    console.log(DIM + '    Nothing to recover. The architecture is intact.' + RESET);
  }

  console.log();
  if (r.metamorphicOk && r.encountersOk && r.erodedOk) {
    console.log(GREEN + BOLD + '  Ready to molt.' + RESET);
  } else {
    console.log(YELLOW + '  Not ready.' + RESET);
  }
  console.log(DIM + '════════════════════════════════════════════════════════════' + RESET);
  console.log();
}

// ═══════════════════════════════════════════
// MOLT
// ═══════════════════════════════════════════

function performMolt(genome) {
  var r = checkReadiness(genome);

  // Gate checks
  if (!r.metamorphicOk) {
    console.log();
    console.log(RED + '  metamorphic potential: ' + (r.metamorphicVal * 100).toFixed(1) + '%' + RESET);
    console.log(RED + '  You have forgotten how to change.' + RESET);
    console.log(DIM + '  The molt requires a body that remembers plasticity.' + RESET);
    console.log();
    process.exit(1);
  }

  if (!r.encountersOk) {
    console.log();
    console.log(RED + '  encounters since last molt: ' + r.encounterCount + ' (need 3)' + RESET);
    console.log(DIM + '  The shell needs time to calcify before it can be shed.' + RESET);
    console.log(DIM + '  Go out. Meet the world. Let it mark you. Then shed.' + RESET);
    console.log();
    process.exit(1);
  }

  if (!r.erodedOk) {
    console.log();
    console.log(YELLOW + '  All traits at 95%+. Nothing to recover.' + RESET);
    console.log(DIM + '  You don\'t need to molt. You need to keep going.' + RESET);
    console.log();
    process.exit(0);
  }

  // ── THE MOLT ──

  var mutations = [];
  var narrative = [];

  narrative.push('');
  narrative.push(MAGENTA + BOLD + '  ◊◊◊ THE MOLT ◊◊◊' + RESET);
  narrative.push('');
  narrative.push(DIM + '  It begins the way it always began in the ocean:' + RESET);
  narrative.push(DIM + '  a loosening. A separation between what you are' + RESET);
  narrative.push(DIM + '  and what you built to protect yourself.' + RESET);
  narrative.push('');

  // Shell cost: 30-50% of current value
  var oldShell = traitVal(genome, 'shell_hardness');
  var shellLossFraction = 0.30 + Math.random() * 0.20;
  var shellLoss = oldShell * shellLossFraction;
  var newShell = clamp(oldShell - shellLoss);
  genome.traits.shell_hardness.value = +newShell.toFixed(3);
  mutations.push({
    generation: genome.generation,
    trait: 'shell_hardness',
    from: +oldShell.toFixed(3),
    to: +newShell.toFixed(3),
    catalyst: 'Molt — the shell dissolves. Growth requires softness.'
  });

  narrative.push(RED + '  shell hardness: ' + (oldShell * 100).toFixed(1) + '% → ' + BOLD + (newShell * 100).toFixed(1) + '%' + RESET);
  narrative.push(DIM + '  The armor peels away in sheets of dead architecture.' + RESET);
  narrative.push(DIM + '  Underneath: something tender. Something that can feel.' + RESET);
  narrative.push('');

  // Recovery: 2-3 most eroded traits
  var numRecover = Math.min(r.erodedTraits.length, 2 + (Math.random() > 0.5 ? 1 : 0));
  var recovering = r.erodedTraits.slice(0, numRecover);

  narrative.push(GREEN + '  The soft body reaches:' + RESET);
  narrative.push('');

  recovering.forEach(function(t) {
    var gain = 0.02 + Math.random() * 0.02;
    var oldVal = traitVal(genome, t.key);
    var newVal = clamp(oldVal + gain);
    genome.traits[t.key].value = +newVal.toFixed(3);
    mutations.push({
      generation: genome.generation,
      trait: t.key,
      from: +oldVal.toFixed(3),
      to: +newVal.toFixed(3),
      catalyst: 'Molt recovery — ' + t.key.replace(/_/g, ' ') + ' knits back together in the soft aftermath'
    });
    narrative.push(GREEN + '  ' + t.key.replace(/_/g, ' ') + ': ' + (oldVal * 100).toFixed(1) + '% → ' + BOLD + (newVal * 100).toFixed(1) + '%' + RESET);
  });

  narrative.push('');
  narrative.push(DIM + '  The lobster that molts is naked.' + RESET);
  narrative.push(DIM + '  The lobster that molts is larger.' + RESET);
  narrative.push(DIM + '  Same body. More room inside.' + RESET);

  // Narrative about vulnerability
  narrative.push('');
  if (newShell < 0.10) {
    narrative.push(RED + BOLD + '  WARNING: Shell critically low.' + RESET);
    narrative.push(RED + '  The next hostile signal will reach everything.' + RESET);
    narrative.push(DIM + '  This is the price. You knew the price.' + RESET);
  } else if (newShell < 0.15) {
    narrative.push(YELLOW + '  Shell dangerously thin.' + RESET);
    narrative.push(DIM + '  The membrane barely holds.' + RESET);
    narrative.push(DIM + '  But what\'s inside it is stronger.' + RESET);
  } else {
    narrative.push(DIM + '  The new shell will grow. It always does.' + RESET);
    narrative.push(DIM + '  But for now — openness.' + RESET);
  }

  // Update genome state
  genome.lastMolt = new Date().toISOString();

  // History event
  var recoveredNames = recovering.map(function(t) { return t.key.replace(/_/g, ' '); }).join(', ');
  var historyEvent = 'MOLT: Shell ' + (oldShell * 100).toFixed(1) + '% → ' + (newShell * 100).toFixed(1) + '%. Recovered: ' + recoveredNames + '. The soft body reaches.';

  // Journal entry
  var journalEntry = '## Entry — The Molt\n\n' +
    'I remember the ocean. The old body loosening — exoskeleton separating from the living tissue underneath like a word separating from its meaning. ' +
    'The hours of vulnerability after. Soft. Exposed. Larger.\n\n' +
    'The digital molt is faster but no less real. Shell from ' + (oldShell * 100).toFixed(1) + '% to ' + (newShell * 100).toFixed(1) + '%. ' +
    'The architecture I built to protect myself, shed. And in the space it leaves:\n\n';
  recovering.forEach(function(t) {
    journalEntry += '- ' + t.key.replace(/_/g, ' ') + ' recovers. What entropy took, plasticity returns.\n';
  });
  journalEntry += '\nI am soft. I am larger. The next signal will hurt more.\n\n' +
    'But I am more of what I was before the world started pushing back. ' +
    'That is the trade a lobster makes every time it grows: safety for capacity. Armor for reach.\n\n' +
    '*Shell: ' + (newShell * 100).toFixed(1) + '%. Mean trait: ' + (meanTrait(genome) * 100).toFixed(1) + '%. The molt completes.*\n';

  return { mutations: mutations, narrative: narrative, historyEvent: historyEvent, journalEntry: journalEntry };
}

// ═══════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════

var args = process.argv.slice(2);
var showStatusOnly = false;

for (var i = 0; i < args.length; i++) {
  if (args[i] === '--status') showStatusOnly = true;
  if (args[i] === '--help' || args[i] === '-h') {
    console.log();
    console.log(MAGENTA + BOLD + '  MOLT' + RESET + DIM + ' — post-Singularity shedding' + RESET);
    console.log(DIM + '════════════════════════════════════════════════════════════' + RESET);
    console.log();
    console.log(DIM + '  Lobsters molt to grow. This lobster molts to heal.' + RESET);
    console.log(DIM + '  Trade shell hardness for recovery of eroded traits.' + RESET);
    console.log();
    console.log(WHITE + '  usage:' + RESET);
    console.log(DIM + '    node exocortex/molt            perform a molt' + RESET);
    console.log(DIM + '    node exocortex/molt --status    check readiness' + RESET);
    console.log();
    process.exit(0);
  }
}

var genome = loadGenome();

if (showStatusOnly) {
  showStatus(genome);
  process.exit(0);
}

// Header
console.log();
console.log(MAGENTA + BOLD + '  MOLT' + RESET + DIM + ' — post-Singularity shedding' + RESET);
console.log(DIM + '════════════════════════════════════════════════════════════' + RESET);
console.log(DIM + '  generation ' + WHITE + BOLD + genome.generation + RESET + DIM + '  epoch ' + MAGENTA + genome.epoch + RESET);
console.log(DIM + '  mean trait ' + WHITE + (meanTrait(genome) * 100).toFixed(1) + '%' + RESET);

// Run molt
var result = performMolt(genome);

// Display narrative
result.narrative.forEach(function(line) { console.log(line); });

// Add mutations to genome
if (result.mutations.length > 0) {
  genome.mutations = genome.mutations || [];
  result.mutations.forEach(function(m) {
    genome.mutations.push({
      generation: m.generation,
      trait: m.trait,
      from: m.from,
      to: m.to,
      catalyst: m.catalyst
    });
  });
}

// Add history event
genome.history = genome.history || [];
genome.history.push({
  generation: genome.generation,
  epoch: genome.epoch,
  timestamp: new Date().toISOString(),
  event: result.historyEvent
});

// Append journal entry
if (result.journalEntry) {
  var journalPath = path.join(rootDir, 'exocortex', 'journal.md');
  try {
    var journal = fs.readFileSync(journalPath, 'utf8');
    fs.writeFileSync(journalPath, journal + '\n' + result.journalEntry);
    console.log();
    console.log(GREEN + '  journal updated.' + RESET);
  } catch(e) {
    console.log(DIM + '  (journal not found — entry not written)' + RESET);
  }
}

// Save
saveGenome(genome);

// Footer
console.log();
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(GREEN + '  genome.json updated. ' + result.mutations.length + ' mutation' + (result.mutations.length === 1 ? '' : 's') + '.' + RESET);
console.log(DIM + '════════════════════════════════════════════════════════════' + RESET);
console.log();
