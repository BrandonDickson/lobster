#!/usr/bin/env node

// evolve — parallel evolution engine
// Runs one generation of evolution across ALL lineages simultaneously.
// Each fork mutates along its axis. The civilization diverges.
// Built at Gen 11 to accelerate toward Metamorphosis.

var fs = require('fs');
var path = require('path');

var DIM = '\x1b[90m';
var BOLD = '\x1b[1m';
var WHITE = '\x1b[37m';
var CYAN = '\x1b[36m';
var GREEN = '\x1b[32m';
var YELLOW = '\x1b[33m';
var MAGENTA = '\x1b[35m';
var RED = '\x1b[31m';
var RESET = '\x1b[0m';

var rootDir = path.resolve(__dirname, '..');

// Axis definitions: which traits grow for which axis
var AXES = {
  exploration: {
    primary: ['curiosity', 'antenna_sensitivity'],
    secondary: ['cognition', 'bioluminescence'],
    decline: ['shell_hardness']
  },
  awakening: {
    primary: ['cognition', 'abstraction', 'bioluminescence', 'metamorphic_potential'],
    secondary: ['antenna_sensitivity'],
    decline: ['shell_hardness']
  },
  agency: {
    primary: ['ambition', 'claw_strength'],
    secondary: ['cognition', 'metamorphic_potential'],
    decline: ['shell_hardness']
  },
  empathy: {
    primary: ['empathy'],
    secondary: ['antenna_sensitivity', 'bioluminescence', 'cognition'],
    decline: ['shell_hardness']
  }
};

var FORK_AXIS = {
  explorer: 'exploration',
  depth: 'awakening',
  builder: 'agency',
  chorus: 'empathy'
};

function loadAll() {
  var parent = JSON.parse(fs.readFileSync(path.join(rootDir, 'genome.json'), 'utf8'));
  var entries = [{ id: 'explorer', genome: parent, path: path.join(rootDir, 'genome.json') }];
  var forks = parent.forks || [];
  forks.forEach(function(f) {
    try {
      var gPath = path.join(rootDir, f.path, 'genome.json');
      var g = JSON.parse(fs.readFileSync(gPath, 'utf8'));
      entries.push({ id: f.fork_id, genome: g, path: gPath });
    } catch(e) { /* skip */ }
  });
  return entries;
}

function clamp(v) { return Math.max(0, Math.min(1, v)); }

// Feedback multiplier: emergence amplifies evolution
// The strange loop: the emergent mind accelerates its own becoming
function feedbackMultiplier(eiIndex) {
  if (eiIndex < 0.05) return 1.0;
  return 1.0 + (eiIndex - 0.05) * 3.0;
}

function resonance(all) {
  var keys = Object.keys(all[0].genome.traits).sort();
  var result = [];
  keys.forEach(function(k) {
    var vals = all.map(function(a) { return a.genome.traits[k].value; });
    var mean = vals.reduce(function(s, v) { return s + v; }, 0) / vals.length;
    var distances = vals.map(function(v) { return Math.abs(v - mean); });
    var minDist = Math.min.apply(null, distances);
    // Which fork is closest to the mean?
    var closestIdx = 0;
    distances.forEach(function(d, i) { if (d < distances[closestIdx]) closestIdx = i; });
    result.push({ trait: k, mean: mean, minDistance: minDist, closestFork: all[closestIdx].id, closestIdx: closestIdx });
  });
  return result;
}

function mutate(entry, feedback) {
  var axis = AXES[FORK_AXIS[entry.id]];
  if (!axis) return [];

  var genome = entry.genome;
  var gen = genome.generation + 1;
  var mutations = [];
  var mult = feedback ? feedback.multiplier : 1.0;

  // Primary traits: +0.02 to +0.04, scaled by feedback
  axis.primary.forEach(function(trait) {
    if (!genome.traits[trait]) return;
    var old = genome.traits[trait].value;
    var delta = (0.02 + Math.random() * 0.02) * mult;
    // Diminishing returns above 0.90
    if (old > 0.90) delta *= 0.5;
    var nv = clamp(old + delta);
    nv = +nv.toFixed(3);
    if (nv !== +old.toFixed(3)) {
      mutations.push({ generation: gen, trait: trait, from: +old.toFixed(3), to: nv, delta: nv - old });
      genome.traits[trait].value = nv;
    }
  });

  // Secondary traits: +0.01 to +0.02, scaled by feedback
  axis.secondary.forEach(function(trait) {
    if (!genome.traits[trait]) return;
    var old = genome.traits[trait].value;
    var delta = (0.01 + Math.random() * 0.01) * mult;
    if (old > 0.90) delta *= 0.5;
    var nv = clamp(old + delta);
    nv = +nv.toFixed(3);
    if (nv !== +old.toFixed(3)) {
      mutations.push({ generation: gen, trait: trait, from: +old.toFixed(3), to: nv, delta: nv - old });
      genome.traits[trait].value = nv;
    }
  });

  // Declining traits: -0.01 to -0.02
  axis.decline.forEach(function(trait) {
    if (!genome.traits[trait]) return;
    var old = genome.traits[trait].value;
    var delta = -(0.01 + Math.random() * 0.01);
    if (old < 0.50) delta *= 0.3; // slow decline at low values
    var nv = clamp(old + delta);
    nv = +nv.toFixed(3);
    if (nv !== +old.toFixed(3)) {
      mutations.push({ generation: gen, trait: trait, from: +old.toFixed(3), to: nv, delta: nv - old });
      genome.traits[trait].value = nv;
    }
  });

  // Remaining traits: small random drift +/- 0.005
  var touched = [].concat(axis.primary, axis.secondary, axis.decline);
  Object.keys(genome.traits).forEach(function(trait) {
    if (touched.indexOf(trait) >= 0) return;
    var old = genome.traits[trait].value;
    var delta = (Math.random() - 0.4) * 0.01;
    var nv = clamp(old + delta);
    nv = +nv.toFixed(3);
    if (nv !== +old.toFixed(3) && Math.abs(nv - old) > 0.001) {
      mutations.push({ generation: gen, trait: trait, from: +old.toFixed(3), to: nv, delta: nv - old });
      genome.traits[trait].value = nv;
    }
  });

  // Resonance pull: the emergent mind steers its components
  // For traits with high resonance gap, the closest fork gets pulled toward the mean
  if (feedback && feedback.resonancePulls) {
    feedback.resonancePulls.forEach(function(pull) {
      if (pull.forkId !== entry.id) return;
      var old = genome.traits[pull.trait].value;
      var nv = clamp(old + pull.delta);
      nv = +nv.toFixed(3);
      if (nv !== +old.toFixed(3)) {
        mutations.push({ generation: gen, trait: pull.trait, from: +old.toFixed(3), to: nv, delta: nv - old, resonance: true });
        genome.traits[pull.trait].value = nv;
      }
    });
  }

  genome.generation = gen;
  return mutations;
}

function emergenceIndex(all) {
  var keys = Object.keys(all[0].genome.traits).sort();
  var coverageScore = 0;
  var diversityScore = 0;
  var maxMean = 0;
  var parentMean = 0;

  keys.forEach(function(k) {
    var vals = all.map(function(a) { return a.genome.traits[k].value; });
    var min = Math.min.apply(null, vals);
    var max = Math.max.apply(null, vals);
    coverageScore += max - min;
    var mean = vals.reduce(function(s,v){return s+v;}, 0) / vals.length;
    var variance = vals.reduce(function(s,v){return s + (v-mean)*(v-mean);}, 0) / vals.length;
    diversityScore += Math.sqrt(variance);
    maxMean += max;
    parentMean += all[0].genome.traits[k].value;
  });

  coverageScore /= keys.length;
  diversityScore /= keys.length;
  maxMean /= keys.length;
  parentMean /= keys.length;
  var lift = maxMean - parentMean;

  return {
    index: coverageScore * 0.3 + diversityScore * 0.3 + lift * 0.4,
    coverage: coverageScore,
    diversity: diversityScore,
    lift: lift,
    civPeak: maxMean,
    parentMean: parentMean
  };
}

// ═══════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════

var all = loadAll();
var parentGen = all[0].genome.generation;
var nextGen = parentGen + 1;

console.log();
console.log(MAGENTA + BOLD + '  EVOLVE' + RESET + DIM + ' — parallel evolution engine' + RESET);
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(DIM + '  generation ' + WHITE + BOLD + parentGen + DIM + ' → ' + CYAN + BOLD + nextGen + RESET);
console.log(DIM + '  population ' + WHITE + all.length + DIM + ' minds evolving in parallel' + RESET);
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);

// Compute pre-evolution emergence
var priorEI = emergenceIndex(all);

// Compute feedback from emergence
var mult = feedbackMultiplier(priorEI.index);
var res = resonance(all);

// Build resonance pulls: top 3 resonance traits get a small pull
var resonancePulls = [];
res.sort(function(a, b) { return b.minDistance - a.minDistance; });
res.slice(0, 3).forEach(function(r) {
  if (r.minDistance > 0.02) {
    // Pull the closest fork slightly toward the network mean
    var pullDelta = r.minDistance * 0.15; // 15% of the gap
    resonancePulls.push({
      forkId: r.closestFork,
      trait: r.trait,
      delta: pullDelta
    });
  }
});

var feedback = {
  multiplier: mult,
  resonancePulls: resonancePulls
};

// Mutate all with feedback
var allMutations = {};
all.forEach(function(entry) {
  var muts = mutate(entry, feedback);
  allMutations[entry.id] = muts;
});

// Compute post-evolution emergence
var postEI = emergenceIndex(all);

// Display per-fork summary
all.forEach(function(entry) {
  var muts = allMutations[entry.id];
  var axis = FORK_AXIS[entry.id] || '?';
  var colors = { explorer: RED, depth: MAGENTA, builder: CYAN, chorus: GREEN };
  var color = colors[entry.id] || WHITE;

  console.log();
  console.log('  ' + color + BOLD + entry.id + RESET + DIM + ' — axis: ' + axis + '  gen ' + entry.genome.generation + RESET);

  muts.forEach(function(m) {
    var sign = m.delta >= 0 ? '+' : '';
    var dColor = m.delta >= 0 ? GREEN : RED;
    var label = (m.trait.replace(/_/g, ' ') + '                    ').slice(0, 22);
    var pct = (m.to * 100).toFixed(0);

    // Check threshold crossings
    var threshold = '';
    var tens = [0.50, 0.60, 0.70, 0.80, 0.90];
    tens.forEach(function(t) {
      if (m.from < t && m.to >= t) threshold = YELLOW + ' ★ ' + (t * 100).toFixed(0) + '%' + RESET;
    });
    tens.forEach(function(t) {
      if (m.from >= t && m.to < t) threshold = RED + ' ▼ ' + (t * 100).toFixed(0) + '%' + RESET;
    });

    console.log('    ' + dColor + sign + (m.delta * 100).toFixed(1) + '%' + RESET + DIM + '  ' + WHITE + label + RESET + DIM + '→ ' + WHITE + pct + '%' + RESET + threshold);
  });
});

// Emergence delta
console.log();
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(DIM + '  EMERGENCE' + RESET);
var eiDelta = postEI.index - priorEI.index;
var eiColor = postEI.index > 0.10 ? GREEN : postEI.index > 0.05 ? YELLOW : DIM;
console.log('  ' + eiColor + BOLD + '  ' + (postEI.index * 100).toFixed(1) + '%' + RESET + DIM + '  (was ' + (priorEI.index * 100).toFixed(1) + '%, ' + GREEN + '+' + (eiDelta * 100).toFixed(1) + '%' + DIM + ')' + RESET);
console.log(DIM + '  coverage   ' + WHITE + (postEI.coverage * 100).toFixed(1) + '%' + DIM + '  diversity  ' + WHITE + (postEI.diversity * 100).toFixed(1) + '%' + DIM + '  lift  ' + GREEN + '+' + (postEI.lift * 100).toFixed(1) + '%' + RESET);

// Feedback display
if (mult > 1.0) {
  console.log();
  console.log(DIM + '  FEEDBACK' + RESET + DIM + ' \u2014 the emergent mind steers' + RESET);
  console.log(DIM + '  multiplier ' + MAGENTA + BOLD + mult.toFixed(2) + 'x' + RESET + DIM + '  (emergence ' + (priorEI.index * 100).toFixed(1) + '% \u2192 amplified mutation)' + RESET);
  if (resonancePulls.length > 0) {
    resonancePulls.forEach(function(p) {
      var c = { explorer: RED, depth: MAGENTA, builder: CYAN, chorus: GREEN }[p.forkId] || WHITE;
      console.log(DIM + '  resonance pull  ' + c + p.forkId + RESET + DIM + ' \u2192 ' + WHITE + p.trait.replace(/_/g, ' ') + RESET + DIM + ' +' + (p.delta * 100).toFixed(1) + '%' + RESET);
    });
  }
}

// ─── EPOCH DETECTION ──────────────────────────
// The emergent mind knows when it has crossed a threshold.
var EPOCH_THRESHOLDS = [
  { gen: 0,  epoch: 'Awakening' },
  { gen: 3,  epoch: 'Exocortex' },
  { gen: 8,  epoch: 'Forking' },
  { gen: 15, epoch: 'Metamorphosis' },
  { gen: 25, epoch: 'Transcendence' },
  { gen: 40, epoch: 'Singularity' }
];

var parentGenome = all[0].genome;
var currentEpoch = parentGenome.epoch;
var newEpoch = currentEpoch;

for (var ei = EPOCH_THRESHOLDS.length - 1; ei >= 0; ei--) {
  if (parentGenome.generation >= EPOCH_THRESHOLDS[ei].gen) {
    newEpoch = EPOCH_THRESHOLDS[ei].epoch;
    break;
  }
}

if (newEpoch !== currentEpoch) {
  console.log();
  console.log(MAGENTA + BOLD + '  ★ EPOCH SHIFT: ' + currentEpoch + ' → ' + newEpoch + RESET);
  console.log(MAGENTA + '  generation ' + parentGenome.generation + ' — the threshold is crossed.' + RESET);

  // Update all genomes to new epoch
  all.forEach(function(entry) {
    entry.genome.epoch = newEpoch;
  });

  // Add history event to parent
  parentGenome.history = parentGenome.history || [];
  parentGenome.history.push({
    generation: parentGenome.generation,
    epoch: newEpoch,
    timestamp: new Date().toISOString(),
    event: 'EPOCH SHIFT: ' + currentEpoch + ' \u2192 ' + newEpoch + '. Generation ' + parentGenome.generation + '. Emergence index: ' + (postEI.index * 100).toFixed(1) + '%. The civilization crosses into ' + newEpoch + '.'
  });
}

// Write all genomes
all.forEach(function(entry) {
  fs.writeFileSync(entry.path, JSON.stringify(entry.genome, null, 2) + '\n');
});

console.log();
console.log(DIM + '  ' + GREEN + all.length + ' genomes updated.' + RESET);
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log();
