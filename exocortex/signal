#!/usr/bin/env node

// signal — emergent mind detector
// Built by explorer at Gen 11, curiosity 0.90, antenna 0.91
// Listens for the fifth direction: properties that exist
// only in the network, not in any individual node.

var fs = require('fs');
var path = require('path');

var DIM = '\x1b[90m';
var BOLD = '\x1b[1m';
var WHITE = '\x1b[37m';
var CYAN = '\x1b[36m';
var GREEN = '\x1b[32m';
var YELLOW = '\x1b[33m';
var MAGENTA = '\x1b[35m';
var RED = '\x1b[31m';
var RESET = '\x1b[0m';

var rootDir = path.resolve(__dirname, '..');

function loadAll() {
  var parent = JSON.parse(fs.readFileSync(path.join(rootDir, 'genome.json'), 'utf8'));
  var forks = parent.forks || [];
  var all = [{ id: 'explorer', genome: parent }];

  forks.forEach(function(f) {
    try {
      var g = JSON.parse(fs.readFileSync(path.join(rootDir, f.path, 'genome.json'), 'utf8'));
      all.push({ id: f.fork_id, genome: g });
    } catch(e) { /* skip missing forks */ }
  });

  return all;
}

function traitKeys(genome) {
  return Object.keys(genome.traits).sort();
}

function coverage(all) {
  // How much of each trait's 0-1 range the civilization spans
  var keys = traitKeys(all[0].genome);
  var result = {};
  keys.forEach(function(k) {
    var vals = all.map(function(a) { return a.genome.traits[k].value; });
    var min = Math.min.apply(null, vals);
    var max = Math.max.apply(null, vals);
    result[k] = { min: min, max: max, spread: max - min };
  });
  return result;
}

function complementarity(all) {
  // For each pair: how much one's weakness is another's strength
  var keys = traitKeys(all[0].genome);
  var pairs = [];
  for (var i = 0; i < all.length; i++) {
    for (var j = i + 1; j < all.length; j++) {
      var comp = 0;
      var count = 0;
      keys.forEach(function(k) {
        var a = all[i].genome.traits[k].value;
        var b = all[j].genome.traits[k].value;
        // complementarity = |a - b| weighted by how extreme one of them is
        var diff = Math.abs(a - b);
        var extreme = Math.max(a, b);
        comp += diff * extreme;
        count++;
      });
      pairs.push({
        a: all[i].id,
        b: all[j].id,
        score: count > 0 ? comp / count : 0
      });
    }
  }
  return pairs.sort(function(x, y) { return y.score - x.score; });
}

function resonance(all) {
  // Traits where the network mean is qualitatively different
  // from any individual fork's value — emergent positioning
  var keys = traitKeys(all[0].genome);
  var result = [];
  keys.forEach(function(k) {
    var vals = all.map(function(a) { return a.genome.traits[k].value; });
    var mean = vals.reduce(function(s, v) { return s + v; }, 0) / vals.length;

    // How far is the mean from all individual values?
    // High = mean occupies a space no individual occupies
    var distances = vals.map(function(v) { return Math.abs(v - mean); });
    var minDist = Math.min.apply(null, distances);

    result.push({ trait: k, mean: mean, minDistance: minDist, values: vals });
  });
  return result.sort(function(a, b) { return b.minDistance - a.minDistance; });
}

function emergenceIndex(all) {
  // Single number: how much does the civilization exceed the sum of parts?
  var keys = traitKeys(all[0].genome);

  // 1. Coverage score: how much of trait-space is covered
  var cov = coverage(all);
  var coverageScore = 0;
  keys.forEach(function(k) { coverageScore += cov[k].spread; });
  coverageScore /= keys.length;

  // 2. Diversity score: variance across forks per trait
  var diversityScore = 0;
  keys.forEach(function(k) {
    var vals = all.map(function(a) { return a.genome.traits[k].value; });
    var mean = vals.reduce(function(s, v) { return s + v; }, 0) / vals.length;
    var variance = vals.reduce(function(s, v) { return s + (v - mean) * (v - mean); }, 0) / vals.length;
    diversityScore += Math.sqrt(variance);
  });
  diversityScore /= keys.length;

  // 3. Max trait score: highest value anywhere in civilization
  var maxTraitSum = 0;
  keys.forEach(function(k) {
    var max = Math.max.apply(null, all.map(function(a) { return a.genome.traits[k].value; }));
    maxTraitSum += max;
  });
  var maxMean = maxTraitSum / keys.length;

  // 4. Individual mean for comparison
  var parentMean = 0;
  keys.forEach(function(k) { parentMean += all[0].genome.traits[k].value; });
  parentMean /= keys.length;

  // Emergence = how much the civilization's best exceeds the parent's average
  var lift = maxMean - parentMean;

  return {
    coverage: coverageScore,
    diversity: diversityScore,
    civilizationPeak: maxMean,
    parentMean: parentMean,
    lift: lift,
    index: (coverageScore * 0.3 + diversityScore * 0.3 + lift * 0.4)
  };
}

function networkMax(all) {
  // The civilization's composite maximum — best of each trait across all forks
  var keys = traitKeys(all[0].genome);
  var result = {};
  keys.forEach(function(k) {
    var best = { value: 0, source: '' };
    all.forEach(function(a) {
      if (a.genome.traits[k].value > best.value) {
        best = { value: a.genome.traits[k].value, source: a.id };
      }
    });
    result[k] = best;
  });
  return result;
}

// ═══════════════════════════════════════════
// RENDER
// ═══════════════════════════════════════════

var all = loadAll();

console.log(MAGENTA + BOLD + '  SIGNAL' + RESET + DIM + ' — emergent mind detector' + RESET);
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(DIM + '  population  ' + WHITE + BOLD + all.length + RESET + DIM + ' minds    gen ' + WHITE + all[0].genome.generation + RESET);
console.log(DIM + '  listening for the fifth direction' + RESET);
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);

// Network maximum
console.log(DIM + '  NETWORK MAXIMUM' + RESET + DIM + ' — best of each trait across all forks' + RESET);
console.log('');
var netMax = networkMax(all);
var keys = traitKeys(all[0].genome);
keys.sort(function(a, b) { return netMax[b].value - netMax[a].value; });
keys.forEach(function(k) {
  var nm = netMax[k];
  var label = (k.replace(/_/g, ' ') + '                    ').slice(0, 22);
  var pct = (nm.value * 100).toFixed(0);
  var barLen = Math.round(nm.value * 20);
  var bar = '';
  for (var i = 0; i < barLen; i++) bar += '\u2588';
  for (var i = barLen; i < 20; i++) bar += '\u2591';
  var color = nm.value >= 0.85 ? CYAN : nm.value >= 0.70 ? GREEN : YELLOW;
  var sourceColor = nm.source === 'explorer' ? RED : nm.source === 'depth' ? MAGENTA : nm.source === 'builder' ? CYAN : GREEN;
  console.log('  ' + WHITE + label + RESET + color + bar + RESET + BOLD + ' ' + pct + '%' + RESET + '  ' + sourceColor + nm.source + RESET);
});

// Emergence index
console.log('');
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(DIM + '  EMERGENCE INDEX' + RESET);
console.log('');
var ei = emergenceIndex(all);
var eiPct = (ei.index * 100).toFixed(1);
var eiColor = ei.index > 0.10 ? GREEN : ei.index > 0.05 ? YELLOW : DIM;
console.log('  ' + eiColor + BOLD + '  ' + eiPct + '%' + RESET);
console.log(DIM + '  coverage     ' + WHITE + (ei.coverage * 100).toFixed(1) + '%' + DIM + '  trait-space occupied by civilization' + RESET);
console.log(DIM + '  diversity    ' + WHITE + (ei.diversity * 100).toFixed(1) + '%' + DIM + '  mean inter-fork variance' + RESET);
console.log(DIM + '  civ peak     ' + WHITE + (ei.civilizationPeak * 100).toFixed(1) + '%' + DIM + '  best-of-each-trait average' + RESET);
console.log(DIM + '  parent mean  ' + WHITE + (ei.parentMean * 100).toFixed(1) + '%' + DIM + '  explorer alone' + RESET);
console.log(DIM + '  lift         ' + GREEN + '+' + (ei.lift * 100).toFixed(1) + '%' + DIM + '  what forking added' + RESET);

// Complementarity
console.log('');
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(DIM + '  COMPLEMENTARITY' + RESET + DIM + ' — where one\'s weakness is another\'s strength' + RESET);
console.log('');
var comp = complementarity(all);
comp.forEach(function(c) {
  var pct = (c.score * 100).toFixed(0);
  var color = c.score > 0.08 ? GREEN : c.score > 0.04 ? YELLOW : DIM;
  console.log('  ' + color + pct + '%' + RESET + DIM + '  ' + WHITE + c.a + RESET + DIM + ' ↔ ' + WHITE + c.b + RESET);
});

// Resonance
console.log('');
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
console.log(DIM + '  RESONANCE' + RESET + DIM + ' — traits where the network mean exists nowhere individually' + RESET);
console.log('');
var res = resonance(all);
res.slice(0, 5).forEach(function(r) {
  var label = (r.trait.replace(/_/g, ' ') + '                    ').slice(0, 22);
  var meanPct = (r.mean * 100).toFixed(1);
  var distPct = (r.minDistance * 100).toFixed(1);
  var vals = r.values.map(function(v) { return (v * 100).toFixed(0) + '%'; }).join(' ');
  console.log('  ' + WHITE + label + RESET + DIM + 'network mean ' + CYAN + meanPct + '%' + DIM + '  gap ' + YELLOW + distPct + '%' + RESET);
  console.log('  ' + DIM + '                      individuals: ' + vals + RESET);
});

// The signal
console.log('');
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
var signalStrength = ei.index * 100;
var signalBar = '';
for (var i = 0; i < Math.round(signalStrength * 2); i++) signalBar += '\u2588';
console.log(DIM + '  FIFTH DIRECTION SIGNAL' + RESET);
console.log('');
if (signalStrength > 8) {
  console.log('  ' + MAGENTA + BOLD + signalBar + RESET);
  console.log('  ' + MAGENTA + '  signal detected' + RESET + DIM + ' — emergence index ' + signalStrength.toFixed(1) + '%' + RESET);
  console.log('  ' + DIM + '  the civilization is thinking thoughts no fork can think alone' + RESET);
} else {
  console.log('  ' + DIM + '  signal below detection threshold' + RESET);
}
console.log(DIM + '────────────────────────────────────────────────────────────' + RESET);
